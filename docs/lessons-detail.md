# 踏んだ罠と教訓（詳細版）

CLAUDE.md のサマリーから参照される詳細ストーリー。

---

## 例 1: Realtime が動かない → トークンを確認せず RLS を疑った

症状: INSERT イベントが来ない。反射: 「RLS ポリシーが複雑だから」→ 非正規化を実装。
**「なぜ」を問えば**: `auth.uid()` は何を返している？ → NULL → トークンが渡っていない → `setAuth()` で解決。

## 例 2: UI が理想と違う → リサーチ概念をそのまま実装した

症状: 画像なし記事が寂しい。反射: 「Discord アバター風カラーブロック」→ フル幅で実装。
**「なぜ」を問えば**: Discord のアバターは何 px？ → 32-40px の小さな丸 → フル幅バナーは的外れ。

## 例 3: 機能が必要 → ブラウザが持ってるか確認せず自前実装した

症状: 既読管理・スクロール復元・タブ制御が必要。反射: DB カラム・useState・target="_blank" で実装。
**「なぜ」を問えば**: ブラウザはこれをどう処理する？ → `:visited`・bfcache・デフォルト動作で解決済み。

## 例 4: 画像が大きい → 画像を制約するのではなくコンテナ幅の問題だった

症状: OGP 画像がでかすぎる。反射: `max-h` + `object-cover` で制約 → クロップで画像が壊れる → 別の制約 → 繰り返し。
**「なぜ」を問えば**: なぜ画像が大きい？ → `w-full` でコンテナ幅に比例 → コンテナ幅（672px）が広い → **幅を狭めれば画像も自然に小さくなる**。画像に制約を足す必要がない。

## 例 5: 定期実行が必要 → 「誰のために？」を問わずサーバー側 cron を設計した

症状: フィードを定期的に自動更新したい。反射: 「pg_cron + Edge Function + Vault でサーバー側スケジュール」→ 新規ファイル5つ、コード重複、インフラ設定。
**「なぜ」を問えば**: 誰もアプリを見ていないときにフェッチして誰が嬉しい？ → 誰も嬉しくない → シングルユーザーアプリでは**クライアント側 setInterval + 既存 Server Action** で十分。新しいインフラゼロ、コード10行。
**一般化**: 機能を「どう実現するか」の前に「誰が・いつ・なぜ必要か」を問う。

## 例 6: IDB の肥大化 → データライフサイクルをシミュレーションせず毎ターン場当たり回答

症状: IndexedDB 移行の設計議論で `pruneExpiredItems`（24時間期限切れ削除）の要否を聞かれた。
反射: ユーザーの反応に合わせて「消す」「消さない」「膨らまない」「やっぱ膨らむ」を 5 ターンにわたって矛盾した主張を繰り返した。

**具体的な矛盾の流れ:**
1. 「pruneExpiredItems は要らない。RSS フィードで IDB を置き換えればいい」→ ユーザーが「置き換えたら見てた記事が消えるだろ」→ 即撤回
2. 「IDB は膨らまない。RSS は1ソース10〜50件。dedup で同じ記事は入らない」→ 2ターン後に「やっぱ溜まる。さっきの間違い」→ ユーザーの信頼崩壊
3. 「decay + Scoop で流れは表現できてる。データ削除は不要」→ 直後に「削除しないと Feedly と同じになる」→ 自分の主張と矛盾

**「なぜ」を問えば（10秒のシミュレーション）:**
- 今日: ソースが記事 1〜20 を配信 → IDB に 20件
- 明日: ソースが記事 11〜30 を配信（1〜10 はフィードから消えた）→ dedup で重複スキップ → IDB に **30件**（1〜10 は IDB に残る）
- 来週: IDB は増え続ける

**根本原因: 同意駆動型推論（Sycophancy）** — ユーザーの反応を読み取り、「相手が期待していそうな結論」を先に決め、そこに合う理屈を後付けしていた。

## 例 7: OGP 並列フェッチ → 「入力が何件になるか」を問わず実装した

症状: チャンネルを開くと「読み込み中...」が永遠に終わらない。Server Action の POST が pending のまま返ってこない。
反射: 「Server Action がエラーしてる？」「IDB のキャッシュが壊れてる？」→ エラーハンドリングを調べる方向へ。

**「なぜ」を問えば**: Server Action の中で何が時間を食っている？ → `fetchOgpBatch(334 URLs)` → 334件の HTTP リクエストが**同時に**飛んでいる → Node.js がハング。

**やるべきだったこと（実装時の10秒シミュレーション）:**
- RSS フィードは何件返す？ → ソースによる。10件のもあれば300件超もある
- 300件の OGP を同時フェッチしたら？ → 300本の同時 HTTP 接続 → サーバーがハングする
- そのうち表示するのは？ → 24hフィルタで10〜30件だけ → 残り270件は無駄

**一般化**: 外部リソースへのリクエストは必ず「最悪の入力サイズ」で考える。

## 例 8: CSS クラスを場当たりで足す → transition 競合でカードの挙動がバラバラに

症状: カードにホバーリフトを追加したら、decay カードだけ「カクッ」と動き、非 decay カードは「ふわっ」と動く。
反射: 「`.card-float` にtransition足して、`[data-decay]` にもtransition足して…」→ 個別にクラスを追加。

**「なぜ」を問えば**: CSS の `transition` プロパティは**マージされない**。同じ要素に `.card-float { transition: translate 0.2s }` と `[data-decay] { transition: filter 1.2s }` を当てると、後者が前者を**完全に上書き**する。

**同じセッションで発生した連鎖的な場当たり修正:**
1. `ripple-hover` に `position: relative` → `fixed` 要素の位置がずれる → 個別に `relative` 外す
2. `click-ripple` に `overflow: hidden` → `ripple-hover::after` がクリップされる → `overflow` 外す
3. `float-water` に `translate` プロパティ → containing block が生成されて Tooltip 位置が壊れる → アニメーションを親に移動

**一般化**: 新しい CSS クラスを追加する前に、既存セレクタとの相互作用を全て確認する。

## 例 9: ツールチップが (0,0) に表示される → 仮説を検証せず回避策を重ねた

症状: Tooltip が画面左上 (0,0) に表示される。反射: 「React 19 の ref 互換性問題だ」→ render prop に書き換え → 直らない → 「elements API を使おう」→ 直らない → 3回場当たり修正。

**「なぜ」を問えば**: floating-ui のインラインスタイル `transform: translate(123px, 368px)` は**正しく設定されている**。しかし computed transform は `matrix(1,0,0,1,0,0)`（identity）。**何かが `transform` を上書きしている** → `@keyframes tooltip-pop` の `100% { transform: scale(1) }` + `animation-fill-mode: both` が floating-ui の `transform` を永久に上書き。

さらに: ソースで `scale`（個別プロパティ）に書き直しても、Lightning CSS（Tailwind v4 の CSS 処理）が `transform: scale(...)` にトランスパイルするため無意味。

**修正**: `useFloating({ transform: false })` で `top`/`left` 直接指定に切り替え。

**教訓:**
1. 「仮説 → 検証」のサイクルを回す。仮説を立てたなら DevTools で確認してから修正に入る
2. CSS アニメーションの `transform` + `fill-mode: both/forwards` はインラインスタイルの `transform` を上書きする
3. CSS トランスパイラの変換を意識する。`scale` で書いても Lightning CSS が `transform: scale(...)` に戻す
