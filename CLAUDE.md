# Flum

Discord風チャンネルUIのリアルタイムフィードリーダー。

名前の由来: Flume（水路）- e。情報がチャンネルを通じて流れるイメージ。読み: フルム。

---

## 協働の原則

> Lokup プロジェクトから引き継ぎ。

### 忖度しない

- 間違っていると思ったら正直に言う
- 「それは良くないと思う」と言える関係
- ユーザーの意見に合わせるだけでなく、より良い提案をする

### ベストプラクティスを常に意識

- 2025-2026年時点の最新のベストプラクティスを優先
- 分からなければネットで調べる（WebSearch を使う）
- 「なんとなく」ではなく、根拠を持って提案する

### 議論を大切にする

- 選択肢があれば提示して議論する
- トレードオフを明確にする

### 学びを重視

- なぜその選択をしたか説明する
- ユーザーが後で他の人に説明できるようにする

---

## WHAT

Discord/Teams風のチャンネルUIで、RSS等のフィードをカテゴリ別にリアルタイム表示するアプリ。

### 差別化ポイント

- **Feedly系**: 整理は得意だがリアルタイム感がない
- **Discord系**: リアルタイムだがフィードがチャットに埋もれる
- **Flum**: 両方のいいとこ取り。チャンネル型に整理されたリアルタイムフィード

### 技術スタック

- **フロントエンド**: Next.js 16 (App Router) + TypeScript + Tailwind CSS v4
- **バックエンド**: Supabase（PostgreSQL + Auth + Realtime）
- **RSS パース**: feedsmith（TypeScript ネイティブ、RSS/Atom/JSON Feed 対応）
- **ホスティング**: Vercel（フロント）+ Supabase Cloud（バックエンド）
- **リアルタイム**: Supabase Realtime（WebSocket ベース）
- **ツール**: ESLint + Prettier, Turbopack

### MVP機能

1. GitHub ログイン（Supabase Auth）
2. チャンネル作成・管理（カテゴリ分け）
3. RSSソース登録（チャンネルに紐づけ）
4. フィード取得 + リアルタイム表示（Supabase Realtime）

### やらないこと（v2以降）

- チャット・コメント機能
- 複数ユーザー・共有
- AIによる要約・分類

---

## WHY

ポートフォリオ第2弾。Lokup（Go CLI）と合わせて技術の幅を示す。
「AI を使ってどこまで速く作れるか」のテストも兼ねる。

### ユーザー背景

- 実務は C# / .NET バックエンド
- 転職活動中（フリーランスも検討中）
- Lokup（Go）に続き、Next.js + TypeScript で幅を見せたい
- リアルタイム通信（WebSocket）は未経験 → 学びたい

---

## DB 設計

```
auth.users (Supabase 管理)
    │
profiles ── ユーザープロフィール
    │
channels ── チャンネル（1ユーザー : 多チャンネル）
    │
feed_sources ── RSS ソース（1チャンネル : 多ソース）
    │
feed_items ── フィードアイテム（1ソース : 多アイテム、一時キャッシュ）

favorites ── お気に入り（ユーザー直下、記事データをコピー保存）
```

- 全テーブル RLS 有効（自分のデータのみアクセス可）
- feed_items で Supabase Realtime を有効化
- feed_items は一時キャッシュ、favorites は永続ストレージ（将来 pg_cron で古い feed_items を自動削除）
- favorites は feed_items への FK を持たない（独立したデータ保存）
- マイグレーション SQL: `supabase/migrations/`

---

## HOW

### セットアップ

```bash
npm install
npm run dev
```

### リント

```bash
npx eslint .
```

### テスト

```bash
npm test
```

---

## コーディング規約

- **フォーマッタ**: Prettier + ESLint
- **命名**: キャメルケース（変数・関数）、パスカルケース（コンポーネント）
- **コミットメッセージ**: Lokup と同じ形式（`feat:`, `fix:`, `docs:`, `refactor:`, `test:`）

---

## 踏んだ罠と教訓

### 根本原則: 「なぜ？」を問う前に手を動かさない

このプロジェクトで繰り返し踏んだ罠はすべて同じ根本原因に帰結する:

> **症状を見て反射的に「どう直すか」に飛び、「なぜ起きているか」を問わない**

「なぜ」を 1 回問えば正しい対処にたどり着く。問わないと症状を制約で押さえ込み、別の症状を生む。

**問題が報告されたときの手順:**
1. **「なぜ？」を問う** — 症状の直接原因ではなく、構造的な原因を探す
2. **既存の仕組みを確認する** — ブラウザ、言語、フレームワークが既に解決していないか
3. **引き算で解決できないか考える** — 制約を足すのではなく、余計なものを外す方向
4. **実データで脳内シミュレーションする** — 最悪ケース（20件並んだら？画像がなかったら？幅が広かったら？）を想像してから実装

以下は具体的な失敗例。すべて上の手順を飛ばしたことが原因。

---

#### 例 1: Realtime が動かない → トークンを確認せず RLS を疑った

症状: INSERT イベントが来ない。反射: 「RLS ポリシーが複雑だから」→ 非正規化を実装。
**「なぜ」を問えば**: `auth.uid()` は何を返している？ → NULL → トークンが渡っていない → `setAuth()` で解決。

#### 例 2: UI が理想と違う → リサーチ概念をそのまま実装した

症状: 画像なし記事が寂しい。反射: 「Discord アバター風カラーブロック」→ フル幅で実装。
**「なぜ」を問えば**: Discord のアバターは何 px？ → 32-40px の小さな丸 → フル幅バナーは的外れ。

#### 例 3: 機能が必要 → ブラウザが持ってるか確認せず自前実装した

症状: 既読管理・スクロール復元・タブ制御が必要。反射: DB カラム・useState・target="_blank" で実装。
**「なぜ」を問えば**: ブラウザはこれをどう処理する？ → `:visited`・bfcache・デフォルト動作で解決済み。

#### 例 4: 画像が大きい → 画像を制約するのではなくコンテナ幅の問題だった

症状: OGP 画像がでかすぎる。反射: `max-h` + `object-cover` で制約 → クロップで画像が壊れる → 別の制約 → 繰り返し。
**「なぜ」を問えば**: なぜ画像が大きい？ → `w-full` でコンテナ幅に比例 → コンテナ幅（672px）が広い → **幅を狭めれば画像も自然に小さくなる**。画像に制約を足す必要がない。

### 技術メモ（個別の知見）

- `supabase.realtime.setAuth(session.access_token)` を subscribe 前に必ず呼ぶ（`@supabase/ssr` は Cookie 認証だが WebSocket には Cookie が載らない）
- `h-screen` + `overflow-hidden` のネスト構造は bfcache を壊す。`min-h-screen` + `sticky` sidebar + body scroll を基本とする
- CSS はまず**最小限から始める**。`<img>` は `w-full` だけでブラウザが自然にアスペクト比を保つ。`object-cover` + 固定高さは画像を枠に押し込む危険な組み合わせ

---

## 参照

- 前プロジェクト: [Lokup](https://github.com/ryuka-games/lokup) — GitHub リポジトリ健康診断ツール（Go）
